// rrtconnect.h : This file contains the 'main' function. Program execution begins and ends there.
//



#include "rrtconnect.h"
//#include "fssimplewindow.h"
//#include <math.h>
//#include <iostream>
//#include <vector>
//#include <map>
//#include <random>
//#include <limits>
//#include <queue>
//#include <set>
//#include <cmath>
//#include <chrono>
//#include <stdlib.h>


bool rrtconnect::IsValidConfiguration(int size_x, int size_y, double* map, CSpaceVertex q, std::vector <double> obst)
// May make class map with obstacles and and map size
{
    int size = obst.size() / 4;

    if (q[0] > size_x || q[1] > size_y)
    {
        return false;
    }

    for (int i = 0; i < size; i++)
    {
        int start = 4 * i;
        double obstaclex = obst[start];
        double obstacley = obst[start + 1];
        double obstaclew = obst[start + 2];
        double obstacleh = obst[start + 3];

        if(obstaclew < 0)
        {
            obstaclex = obstaclex + obstaclew;
            obstaclew = fabs(obstaclew);
        }
        if(obstacleh < 0)
        {
            obstacley = obstacley + obstacleh;
            obstacleh = fabs(obstacleh);
        }

        double relativeX, relativeY;
        relativeX = q[0] - obstaclex;
        relativeY = q[1] - obstacley;
        if (0 <= relativeX && relativeX < obstaclew && 0 <= relativeY && relativeY < obstacleh)
        {
            return false;
        }
    }
    return true;
}

CSpaceVertex rrtconnect::sampleRandomVertex(double* map, int x_size, int y_size, std::vector <double> obst)
{

    while (1)
    {
        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        // std::nextafter(2.0*M_PI, std::numeric_limits<RealType>::max()
        std::uniform_real_distribution<> dis(0, std::max(x_size, y_size));
        CSpaceVertex sampleVertex;
        for (int n = 0; n < 2; n++)
        {
            // Use dis to transform the random unsigned int generated by gen into a 
            // double in [1, 2). Each call to dis(gen) generates a new random double

            const double a = dis(gen);
            sampleVertex.push_back(a);

        }

        if (IsValidConfiguration(x_size, y_size, map, sampleVertex, obst))
        {

            return sampleVertex;
        }
        else
        {
            //std::cout << "Sample generated is not valid. Generate new sample" << std::endl;
        }
    }

}

float rrtconnect::VertexDistance(CSpaceVertex v1, CSpaceVertex v2)
{
    float sum = 0;
    for (int i = 0; i < v1.size(); i++)
    {
        sum += abs((v1[i] - v2[i]) * (v1[i] - v2[i]));


    }
    return sqrt(sum);
}

void rrtconnect::printCSpaceVertex(CSpaceVertex v)
{
    for (int i = 0; i < v.size(); i++)
    {
        std::cout << v[i] << ",";
    }
    std::cout << std::endl;
}

int rrtconnect::RRTNearestNeighbour(Tree& tree, CSpaceVertex q_rand) //, int numofDOFs, double*	map,int x_size, int y_size
{

    int size = tree.size();
    double min_dist = 1000000; // Initialize very high value
    double dist;
    int nn_index; // Index of nearest neighbour
    for (int i = 0; i < size; i++)
    {
        dist = VertexDistance(q_rand, tree[i]->vertex);
        if (dist < min_dist)
        {
            min_dist = dist;
            nn_index = i;

        }
    }

    return nn_index;

}

bool rrtconnect::LocalPlanner(double* map, int x_size, int y_size, CSpaceVertex v1, CSpaceVertex v2, int num_steps, std::vector <double> obst)
{
    // From v1 to v2
    int size = v1.size();
    CSpaceVertex increment;
    for (int i = 0; i < size; i++)
    {
        increment.push_back((v2[i] - v1[i]) / num_steps);
    }

    for (int i = 0; i < num_steps; i++)
    {
        // CSpaceVertex temp;
        for (int j = 0; j < size; j++)
        {
            v1[j] = v1[j] + increment[j];
        }

        if (IsValidConfiguration(x_size, y_size, map, v1, obst)) continue;
        else return false;
    }

    return true;
}

CSpaceVertex rrtconnect::AltRRTGenerateNewVertex(Tree& tree, CSpaceVertex q_rand, int q_near_index, double max_step, int numofDOFs, double* map,
    int x_size, int y_size, int num_steps, std::vector <double> obst)
{

    CSpaceVertex q_new; // Initialize q_new


    double dist = VertexDistance(q_rand, tree[q_near_index]->vertex);

    if (dist < max_step)
    {
        return q_rand; // The random vertex is itself the new vertex
    }



    else
    {
        double resolution = 0.001;
        dist = 0;

        CSpaceVertex q_near = tree[q_near_index]->vertex;
        CSpaceVertex q_new_int = q_near;
        CSpaceVertex increment;

        for (int i = 0; i < q_near.size(); i++)
        {
            if (q_rand[i] > q_near[i]) increment.push_back(1);
            else increment.push_back(-1);
        }

        while (dist < max_step)
        {

            for (int i = 0; i < q_rand.size(); i++) // Increase each joint config linearly by value ofresolution
            {
                if (increment[i] == 1)
                {
                    q_new_int[i] = q_new_int[i] + increment[i] * resolution;
                    if (q_new_int[i] > q_rand[i]) q_new_int[i] = q_rand[i];
                }

                if (increment[i] == -1)
                {
                    q_new_int[i] = q_new_int[i] + increment[i] * resolution;
                    if (q_new_int[i] < q_rand[i]) q_new_int[i] = q_rand[i];
                }
            }

            //   double arr[5];

            //   for(int i = 0; i < q_rand.size();i++) 
            //   {
            //     arr[i] = q_new_int[i];
            //   }

            if (IsValidConfiguration(x_size, y_size, map, q_new_int, obst) && VertexDistance(q_near, q_new_int) < max_step)
            {
                //std::cout << "Potential new node is valid and within max_step" << std::endl;
                if (LocalPlanner(map, x_size, y_size, q_near, q_new_int, num_steps, obst))
                {
                    //std::cout << "Local Planner can find valid path " << std::endl;
                    dist = VertexDistance(q_near, q_new_int);
                    q_new = q_new_int;
                }

                else break;


            }
            else break;


        }

    }

    return q_new; // If q_new returned is empty, then no new node was created, generate random node again 

}


void rrtconnect::RRTAddVertex(Tree& tree, CSpaceVertex q_new, int nn_index, int& count)
{

    RRTNode* temp = new RRTNode;
    temp->index = count;
    temp->parent_index = nn_index;
    temp->vertex = q_new;
    temp->cost = tree[nn_index]->cost + VertexDistance(q_new, tree[nn_index]->vertex); // Is it correct?

    tree.push_back(temp);
    count++;

}

std::vector<int> rrtconnect::RRTConnectExtend(Tree& tree, CSpaceVertex q, int q_near_index, double max_step, int numofDOFs, double* map,
    int x_size, int y_size, int num_steps, int& count, std::vector <double> obst)
{

    int trapped = 0;
    int state = 0;

    CSpaceVertex q_connect;

    while (!trapped)
    {
        q_connect = AltRRTGenerateNewVertex(tree, q, q_near_index, max_step, numofDOFs, map, x_size, y_size, num_steps, obst);
        if (q_connect.empty())
        {
            state = 1; // Trapped
            break; // No new vertex was able to be generated
        }
        else if (q_connect == q)
        {
            state = 2; // Reached
            break;
        }
        else
        {
            RRTAddVertex(tree, q_connect, q_near_index, count);
            q_near_index = count - 1;
        }

    }


    std::vector<int>state_vector = { state,q_near_index };

    return state_vector; // If q_new returned is empty, then no new node was created, generate random node again 


}

std::vector<CSpaceVertex> rrtconnect::plannerRRTConnect(
    double* map,
    int x_size,
    int y_size,
    CSpaceVertex start,
    CSpaceVertex goal,
    int numofDOFs,
    std::vector <double> obst
)
{
    //no plan by default

  // auto start = std::chrono::high_resolution_clock::now();
    // *plan = NULL;
    // *planlength = 0;
    FsPollDevice();
    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
    FsSwapBuffers();
    FsSleep(5);



    Tree tree1; // Initialize tree1
    Tree tree2; // Initialize tree1

    int count1 = 0; // Index in the tree
    int count2 = 0;

    int max_iter = 80000; // Number of itrations to run
    double max_step = 10; // Define epsilon for max_step distance
    int num_steps = 20; // Define num_steps for local planner
    int goal_index;
    int goal_reached = 0;
    int tree1_connect_index;
    int tree2_connect_index;
    // int state;
    std::vector<CSpaceVertex> path;
    std::vector<CSpaceVertex> path1;
    std::vector<CSpaceVertex> path2;

    CSpaceVertex start_pos;
    CSpaceVertex goal_pos;
    CSpaceVertex q_rand;
    CSpaceVertex q_near;
    CSpaceVertex q_new;
    CSpaceVertex q_connect;
    CSpaceVertex placeholder = { -1,-1,-1,-1,-1 };
    int nn_index; // Nearest neighbour index in tree
    int nn_index_extend; // Nearest neighbour in other tree 


    // for(int i = 0; i < numofDOFs; i++)
    // {
    //   start_pos.push_back(armstart_anglesV_rad[i]);
    // }




    // for(int i = 0; i < numofDOFs; i++)
    // {
    //   goal_pos.push_back(armgoal_anglesV_rad[i]);
    // }

    start_pos = start;
    goal_pos = goal;
    /*

      Initializing start and goal node and adding them to tree1 and tree2

    */

    RRTNode* start_node = new RRTNode;

    start_node->index = count1;
    start_node->parent_index = -1; // -1 as it is root of the tree
    start_node->vertex = start_pos;
    start_node->cost = 0;

    tree1.push_back(start_node); // Add root node to tree
    count1++;


    RRTNode* goal_node = new RRTNode;

    goal_node->index = count2;
    goal_node->parent_index = -1; // -1 as it is root of the tree
    goal_node->vertex = goal_pos;
    goal_node->cost = 0;

    tree2.push_back(goal_node); // Add root node to tree
    count2++;


    // We use start_tree variable to basically implement the swapping of the trees.

    bool start_tree = true;

    /*MAIN FOR LOOP - RUNNING FOR MAX_ITER ITERATIONS */

    for (int i = 0; i < max_iter; i++)
    {

        if (start_tree)
        {

            if (i % 10000 == 0 && i != 0) std::cout << "Number of iterations is " << i << std::endl;

            /* Generate Random Configuration */

            // Sample random vertex - No goal biasing in RRT connect

            q_rand = sampleRandomVertex(map, x_size, y_size, obst);


            /* Get nearest neighbour */

            nn_index = RRTNearestNeighbour(tree1, q_rand);
            q_new = AltRRTGenerateNewVertex(tree1, q_rand, nn_index, max_step, numofDOFs, map, x_size, y_size, num_steps, obst);
            if (q_new.empty())
            {
                std::cout << "New vertex wasnt able to be Generated. Break" << std::endl;
                continue; // Go to next iterations
            }

            RRTAddVertex(tree1, q_new, nn_index, count1);

            // Code for extend operation
            nn_index_extend = RRTNearestNeighbour(tree2, q_new); // Nearest neighbour with new node generated above
            std::vector<int> state = RRTConnectExtend(tree2, q_new, nn_index_extend, max_step, numofDOFs, map, x_size, y_size, num_steps, count2, obst);

            // Draw(tree1,obst);
            // Draw(tree2,obst);
            Drawtwotrees(tree1, tree2, obst, start, goal);
            // auto DT=std::chrono::high_resolution_clock::now()-t0;
            // auto millisec=std::chrono::duration_cast <std::chrono::milliseconds> (DT).count();

            if (state[0] == 2)
            {
                std::cout << "Trees were connected " << std::endl;
                tree1_connect_index = count1 - 1;
                tree2_connect_index = state[1];
                goal_reached = 1;
                std::cout << "Total vertices in both trees combined is " << tree1.size() + tree2.size() << std::endl;
                std::cout << "vertices in trees 1 is " << tree1.size() << std::endl;
                std::cout << "vertices in tree 2 is " << tree2.size() << std::endl;
                break;
            }

            start_tree = !start_tree;

        }

        else
        {

            /* Generate Random Configuration */

            // Sample random vertex - No goal biasing in RRT connect

            q_rand = sampleRandomVertex(map, x_size, y_size, obst);


            /* Get nearest neighbour */

            nn_index = RRTNearestNeighbour(tree2, q_rand);
            q_new = AltRRTGenerateNewVertex(tree2, q_rand, nn_index, max_step, numofDOFs, map, x_size, y_size, num_steps, obst);
            if (q_new.empty())
            {
                //std::cout << "New vertex wasnt able to be Generated. Break" << std::endl;
                continue; // Go to next iterations
            }

            RRTAddVertex(tree2, q_new, nn_index, count2);

            // Code for extend operation

            nn_index_extend = RRTNearestNeighbour(tree1, q_new); // Nearest neighbour with new node generated above

            std::vector<int> state = RRTConnectExtend(tree1, q_new, nn_index_extend, max_step, numofDOFs, map, x_size, y_size, num_steps, count1, obst);
            Drawtwotrees(tree1, tree2, obst, start, goal);
            // auto DT=std::chrono::high_resolution_clock::now()-t0;
            // auto millisec=std::chrono::duration_cast <std::chrono::milliseconds> (DT).count();

            if (state[0] == 2)
            {
                std::cout << "Trees were connected " << std::endl;
                tree1_connect_index = state[1];
                tree2_connect_index = count2 - 1;
                goal_reached = 1;
                std::cout << "Total vertices in both trees combined is " << tree1.size() + tree2.size() << std::endl;
                std::cout << "vertices in trees 1 is " << tree1.size() << std::endl;
                std::cout << "vertices in tree 2 is " << tree2.size() << std::endl;

                break;
            }

            start_tree = !start_tree;


        }
        //FsPollDevice();



    }

    //FsSleep(3000);
    /* BAcktracking to get path */

    if (goal_reached == 1)
    {
        int parent_index1 = tree1_connect_index;
        while (parent_index1 != -1)
        {

            CSpaceVertex temp = tree1[parent_index1]->vertex;
            path1.push_back(temp);
            parent_index1 = tree1[parent_index1]->parent_index;
        }
        int parent_index2 = tree2_connect_index;
        while (parent_index2 != -1)
        {

            CSpaceVertex temp = tree2[parent_index2]->vertex;
            path2.push_back(temp);
            parent_index2 = tree2[parent_index2]->parent_index;
        }


        // Creating the final path by reversing path1 and appending path 2.

        std::reverse(path1.begin(),path1.end()); // change it back
        path1.insert(std::end(path1), std::begin(path2), std::end(path2));
        path = path1;

    }

    else { std::cout << "PATH WASNT FOUND !!!!!!!!!!!!!!!!!!!" << std::endl; }

    // int numofsamples = path.size();
    // if(numofsamples < 2){
    //     printf("the arm is already at the goal\n");
    //     return;
    // }
    // *plan = (double**) malloc(numofsamples*sizeof(double*));
    // int firstinvalidconf = 1;
    // for (int i = 0; i < numofsamples; i++){
    //     (*plan)[i] = (double*) malloc(numofDOFs*sizeof(double)); 

    //     }

    // for(int j =0; j < numofsamples; j++)
    // {
    //   for(int i = 0; i < numofDOFs; i ++)
    //   {
    //     (*plan)[j][i] = path[j][i];
    //   }
    // }

    // *planlength = numofsamples;


    double total_cost = tree1[tree1_connect_index]->cost + tree2[tree2_connect_index]->cost
        + VertexDistance(tree1[tree1_connect_index]->vertex, tree2[tree2_connect_index]->vertex);

    std::cout << "Cost of path is " << total_cost << std::endl;

    //std::cout << "Deleting Trees" << std::endl;

    for (int i = 0; i < tree1.size(); i++)
    {

        delete tree1[i];
        tree1[i] = nullptr;
    }

    for (int i = 0; i < tree2.size(); i++)
    {

        delete tree2[i];
        tree2[i] = nullptr;
    }

    //     auto end = std::chrono::high_resolution_clock::now();
    // std::chrono::duration<double> elapsed_seconds = end - start;
    // std::cout << "Time taken for planning is " << elapsed_seconds.count() << std::endl;

    std::cout << "Size of Plan is " << path.size() << std::endl;

    // Print Path


// FsPollDevice();
// for(int i = 0; i < 10000; i++)
// {
// glColor3ub(0,0,255);
// glBegin(GL_LINES);

// glVertex2d(200, 200);
// glVertex2d(500, 500);
// glEnd();
// // FsSwapBuffers

// }
    DrawPath(path, obst, start, goal);
    Moverobot(path, obst, start, goal);



    return path;

}

